{"pages":[],"posts":[{"title":"github actions 自动部署 hexo","text":"准备 Personal access token - 用于 hexo deploy 部署到 github 的认证。设置在setting/developer settings 下 Secrets - 用户挂在在 github actions 下的env环境变量, 这里可以存放不想暴露在 actions log 中的字段, 比如上面的 access token 需要保存在此。设置在repository下的 setting hexo 配置改造修改 _config.yml 下 deploy 中的 repo 链接, TOKEN 就是我们刚生成的 access token, 这里使用 TOKEN 作为标记符号是为了在 actions 环境中方便替换。 1234deploy: type: git repo: https://TOKEN@github.com/Ininit/ininit.github.io branch: master workflows 文件配置配置 github acitons 的配置文件, 在仓库actions中选择 nodejs 作为 workflow 环境 123456789101112131415161718192021222324252627282930313233343536373839# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actionsname: deploy blogon: push: branches: [ source ]jobs: build: runs-on: macOS-latest ## 选择系统环境 steps: - uses: actions/checkout@v1 ## 检出 github 代码 - name: use nodejs uses: actions/setup-node@v1 ## 使用 node with: node-version: \"12.x\" - name: init run: | git config --global user.email \"meininit@gmail.com\" git config --global user.name \"Ininit\" npm install -g yarn yarn global add hexo-cli yarn add -D hexo-deployer-git ## 使用 hexo deploy 中的 git 需要安装这个插件 - name: yarn install run: | yarn - name: deploy env: TOKEN: ${{secrets.DEPLOY_KEY}} ## 这里就是在 Secrets 配置的 access token run: | sed -i \"\" \"s/TOKEN/$TOKEN/\" _config.yml ## 替换掉配置中的 TOKEN 标记 yarn build echo \"blog.ininit.me\" >> public/CNAME ## 自定义域名配置 CNAME yarn deploy 总结 我的是 源码与 page 是同一个仓库, 所以 branches 是 source 分支, page 在 master 分支 关键在于设置 access token 到仓库的 secrets 中","link":"/2020/04/29/github%20actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20hexo/"},{"title":"hexo邂逅travis","text":"使用travis自动化部署Blog到GitHub Page 准备工作 Github - 托管Blog工程和Page静态网站 Travis - 自动部署blog到VPS 创建github仓库托管静态页面这里仓库名一定要以github.io结尾。新建后看可以在Seting看到github page域名为[用户名].github.io结尾 生成token 这是为了授权给travis管理Blog仓库。 在github的设置界面找到，Seting>Developer setting>Personal access tokens>Generate new tokens 给token新起一个名字，选择repe权限，这里全选。然后生成后记得保存token，界面一旦推出就需要重新生成了。 Travis配置 使用github账户登录travis，在主界面选择托管Blog源码的仓库开启travis服务。 打开setting，找到General设置将Build only if .travis.yml is present和Build pushed branches 复选，travis会在你push代码到github仓库后触发travis拉去代码进行自动构建。 在AutoCancellation设置将两个选项复选。 重点 在Environment Variables变量设置，添加刚生成的token为__TOKEN__。display value in log不要复选，复选将这些信息暴露在日志上，日志是公开的。 .travis.yml配置12345678910111213141516171819language: node_jsdist: trustynode_js: stableinstall:- npm install hexo-cli -g- npm installbefore_script:- git config --global user.name \"ininit\"- git config --global user.email \"meininit@gmail.com\"- sed -i \"s/__TOKEN__/${__TOKEN__}/\" _config.ymlscript:- hexo clean- hexo generate- hexo deploybranches: only: - source 最后通过上述设置每次更新Blog提交到github后travis会自动拉取构建执行hexo deploy后就会推送到仓库master分支。","link":"/2019/03/15/hexo%E9%82%82%E9%80%85travis/"},{"title":"sentry之docker安装与配置","text":"前言最近公司再搞重构，我顺势也把之前遗留问题解决并加上bug收集机制。可以及时看到用户在自己项目使用中产生的bug，顿时神清气爽。 sentry 是一个支持大多数语言和框架bug收集报告的平台， 该平台有开源和saas服务，这里我们使用它开源代码进行自建bug收集平台。 准备工作 我是给公司配置该服务，直接用公司服务器线上服务器。 一台Linux （这里我直接用docker进行搭建，所以任意类型的服务器都问题不大） Docker sentry 项目onpremise 安装 拉去 onpremise 项目 1git clone https://github.com/getsentry/onpremise.git 安装 1./install.sh 脚本执行过程中需要拉去docker镜像，速度慢的同学可以google docker 镜像加速 网易。 最后根据提示创建用户， 如果这过程没有看到，待完成自己执行docker-compose run --rm web createuser创建用户，这里我创建第一个用户设为超级管理员。 完成 关闭该网站，打开官方文档，开始体验，就是这么简单。 配置smtp 服务搭都搭建了，怎么能少了服务通知呢，我们不可能一直打开服务看着。我这里配置是使用qq邮箱SMTP进行邮件发送。我看大家基本都是搭建邮件转发钉钉，大家可以了解一下。 1234The recommended way to customize your configuration is using the files below, in that order: config.yml sentry.conf.py .env w/ environment variables 项目介绍提示我们配置按照三个配置文件优先级进行配置，优先使用 config.yml 1234567mail.backend: 'smtp'mail.host: 'smtp.qq.com'mail.port: 587mail.username: '10086@qq.com'mail.password: '授权码'mail.use-tls: truemail.from: '10086@qq.com' # 这个一定要跟username一样不然qq会拒绝 完成这个前，要先到 QQ邮箱/设置/账户 开启SMTP服务。配置好后执行docker-compose up, 这里加上-d是为了方便观察问题，如果直接后台运行后出错是很难纠错，我们通过看docker-compose.yml文件可以看到每个服务restart: unless-stoped。如果不停止，他会一直尝试重启。当我们发现出错可以按ctrl+c停止容器运行。 独立服务 因为公司不可能只有sentry服务运行，还有其他服务，这时候我们可以通过定制把相同的服务进行合并，这里我将redis服务独立出来，再进行docker-compose down/up不会影响其他服务。 注释掉 sentry 的 redis 服务12345678910111213... depends_on:# - redis - postgres - memcached - smtp......# redis:# restart: unless-stopped# image: redis:3.2-alpine... 这样我们就将内置的 redis 去掉了，下面添加外部 reids 1234... environment: SENTRY_REDIS_HOST: redis # 这里不需要注释... 如果直接在上面写外部 redis 名称是没办法访问到的，通过网上一顿瞎找， 找到可以将容器网络模式设为 bridge 桥接。 12345... volumes: - sentry-data:/var/lib/sentry/files network_mode: bridge... 我们设置这里是不够的，SMTP，memcached，postgres 也需要跟 web, worker, cron 通信，所以我们也要将他们的网络模式设置为 bridge。 通过 docker-compose up --build 可以启动前重新构建，得益于docker缓存技术，几乎跟直接启动无差别。 启动后我们发现还是无法通信到外部 redis 通过 google 一顿查询，我们需要通过link机制将外部 redis 链接到 web 等服务 12345... network_mode: bridge external_links: - redis-server: redis # 这里用了别名，因为外部服务名字不叫redis，这里我就将它设置别名方便。... 这种模式是单向的，就是 sentry 服务能够访问外部 redis 服务， 外部不能访问到 sentry 的服务。 一顿操作 docker-compose up --build -d 大功告成。 感谢Docker Compose：链接外部容器的几种方式","link":"/2019/07/11/sentry%E4%B9%8Bdocker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"webpack4 构建速度提升","text":"#0x01 性能瓶颈分析在这里我使用的是speed-measure-webpack-plugin 插件进行构件速度分析 1234567891011121314// https://www.npmjs.com/package/speed-measure-webpack-plugin// speed-measure-webpack-plugin 简单使用方法yarn add -D speed-measure-webpack-plugin// usageconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\")const smp = new SpeedMeasurePlugin()const webpackconfig = smp.wrap({ plugins: [ ... ]}) 获得构建速度数据 总过耗时240s Plugins 耗时最严重是ProgressPlugin 耗时 10s Loaders 耗时严重的有url-loader 55s、vue-loader 80s、babel-loader 40s 基于 development模式，每次rebuild需要3s以上 #0x02 针对上面做数据做优化1. 优化DevTool Production 模式 如果需要隐藏直接 none 模式即可 如果需要搭配 sentry 这类 bug 追踪服务推荐使用 hidden-source-map Development 模式 eval eval-source-map eval-cheap-source-map eval-cheap-module-source-map ☑️ 2. 优化 loader 解析时间 thread-loader 将这个 loader 放在其他loader 即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// thread-loader 预热const jsWorkerPool = { // options // 产生的 worker 的数量，默认是 (cpu 核心数 - 1) // 当 require('os').cpus() 是 undefined 时，则为 1 workers: 2, // 闲置时定时删除 worker 进程 // 默认为 500ms // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在 poolTimeout: 2000};const vueWorkerPool = { // 一个 worker 进程中并行执行工作的数量 // 默认为 20 workerParallelJobs: 2, poolTimeout: 2000};threadLoader.warmup(jsWorkerPool, ['babel-loader']);threadLoader.warmup(vueWorkerPool, ['vue-loader']);const webpackConfig = { ... module: { rules: [ { test: /\\.(js|jsx)/, exclude: /node_modules/, use: [ { loader: 'thread-loader', options: jsWorkerPool }, 'babel-loader?cacheDirectory' ] }, // vue { test: /\\.vue$/, use: [ { loader: 'thread-loader', options: vueWorkerPool }, 'vue-loader' ] } ] } ...} 3. 利用缓存使用 webpack 缓存的方法有几种，例如使用 cache-loader，HardSourceWebpackPlugin 或 babel-loader 的 cacheDirectory 标志。 所有这些缓存方法都有启动的开销。 重新运行期间在本地节省的时间很大，但是初始（冷）运行实际上会更慢 cache-loader 与 thread-loader 使用方式一样，仅在开销大的 loader 之前添加该 loader, 将结果缓存到磁盘里面， 显著提升二次构建速度（我的磁盘太烂没有用） HardSourceWebpackPlugin 1234567891011121314151617181920212223242526272829303132333435363738394041new HardSourceWebpackPlugin({ // cacheDirectory是在高速缓存写入。默认情况下，将缓存存储在node_modules下的目录中 // 'node_modules/.cache/hard-source/[confighash]' cacheDirectory: path.join(__dirname, './lib/.cache/hard-source/[confighash]'), // configHash在启动webpack实例时转换webpack配置， // 并用于cacheDirectory为不同的webpack配置构建不同的缓存 configHash: function(webpackConfig) { // node-object-hash on npm can be used to build this. return require('node-object-hash')({sort: false}).hash(webpackConfig); }, // 当加载器、插件、其他构建时脚本或其他动态依赖项发生更改时， // hard-source需要替换缓存以确保输出正确。 // environmentHash被用来确定这一点。如果散列与先前的构建不同，则将使用新的缓存 environmentHash: { root: process.cwd(), directories: [], files: ['package-lock.json', 'yarn.lock'], }, // An object. 控制来源 info: { // 'none' or 'test'. mode: 'none', // 'debug', 'log', 'info', 'warn', or 'error'. level: 'debug', }, // Clean up large, old caches automatically. cachePrune: { // Caches younger than `maxAge` are not considered for deletion. They must // be at least this (default: 2 days) old in milliseconds. maxAge: 2 * 24 * 60 * 60 * 1000, // All caches together must be larger than `sizeThreshold` before any // caches will be deleted. Together they must be at least this // (default: 50 MB) big in bytes. sizeThreshold: 50 * 1024 * 1024 }, }), new HardSourceWebpackPlugin.ExcludeModulePlugin([ { test: /.*\\.DS_Store/ } ]), 4. DllPlugin 加速将不经常更换的依赖包进行拆解打包处理，提升构建速度。这里我采用 autodll-webpack-plugin 123456789101112131415161718192021222324// https://github.com/asfktz/autodll-webpack-plugin/tree/master/experiments/inheritconst AutoDllPlugin = require('autodll-webpack-plugin')// dll 打包注入new AutoDllPlugin({ inject: true, // will inject the DLL bundles to index.html filename: '[name].js', entry: { vendor: [ 'vue', 'vuex', 'vue-router' ], util: [ 'vue-cropper', 'viser-vue', 'vue-lazyload', 'echarts', 'moment', ], atdv: [ 'ant-design-vue' ] }}), #0x03 结果 总过耗时43s Plugins 耗时最严重是ProgressPlugin 耗时 10s Loaders 耗时严重的有url-loader 18s、vue-loader 55s、babel-loader 46s 基于 development模式，每次rebuild需要1.5s左右 #0x04 参考链接 https://github.com/asfktz/autodll-webpack-plugin/tree/master/experiments/inherit https://github.com/sisterAn/blog/issues/63","link":"/2020/04/28/webpack4%20%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87/"},{"title":"初始化gitconfig","text":"初始化gitconfig 新环境一切以config为头 设置用户名 git config global user.name \"Ininit\" 设置邮箱 git config global user.email \"explam@abc.com 设置vsc为默认编辑器 git config global core.editor \"code --wait\" 设置difftool git config --global -e 粘贴 1234[diff] tool = vscode[difftool \"vscode\"] cmd = code --wait --diff $LOCAL $REMOTE 待续。。。","link":"/2019/03/15/%E5%88%9D%E5%A7%8B%E5%8C%96gitconfig/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"travis","slug":"travis","link":"/tags/travis/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[]}